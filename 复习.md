# 操作系统

##### 1. 死锁

当一个进程占有部分资源同时在等待另一资源，而该资源被另一等待进程占有，且该进程暂时不能释放该资源，这种情况称为死锁；

**死锁的四个条件**

- 互斥。一个资源只能被一个进程占有，无法共享。
- 占有并等待。进程必须占有一部分资源，并等待一些资源。
- 非抢占。资源一旦被占有，只能等待进程主动释放，不能被其他进程抢占。
- 循环等待。P1占有资源A，等待资源B，P2占有资源B，等待资源C，P3占有资源C，等待资源A。

**防止死锁**

就是打破四个条件。

1. 把资源改成共享资源（不科学）
2. 进程必须先占有资源，才能去请求资源。
3. 当进程没有得到所需要的所有资源，就释放现在占有的资源。
4. 优先级。进程必须先拥有资源A，才能请求资源B，否则不能请求。

##### 2. 进程、线程

- 进程、线程是什么？

  进程是系统进行资源分配和调度的基本单位

  线程是进程的一部分，是CPU调度的基本单位。

  一个程序至少有一个进程，一个进程至少有一个内存

- 进程和线程的区别

  线程占用资源少，创建、删除代价低，易于调度，高并发性，易于切换，适合计算（CPU）密集型应用，但是相关性强，独立性差，编程难度高。

- 进程间通信

  信号(用于通知接受进程某个事件已经发生)、信号量（是一个计数器，控制多个进程对共享资源的访问，锁机制）、套接字（用于不同机器）、共享内存、消息队列、管道、有名管道

- 线程间通信

  互斥量、信号量、事件、临界区

- 多进程和多线程的使用场景

  需要频繁创建销毁——线程

  需要大量计算——线程

  相关性强——线程，相关性较弱——进程

  可能扩展到多机分布——进程，多核分布——线程



# 数据库

##### 1. 事务属性

- 原子性：要么转钱要么没转
- 一致性：A向B转钱，加起来总额不变
- 隔离性：A向B转钱，A向C转钱是不冲突的
- 持久性：转钱之后的结果持久

##### 2. 关系型数据库和非关系型

| 数据库类型                          | 特性                                                         |                                                              |                                                              |
| ----------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 关系型数据库SQLite、Oracle、mysql   | 1. 关系型数据库，是指采用了关系模型来组织数据的数据库；<br />2. 关系型数据库的最大特点是事务的一致性<br />3. 关系模型指的就是二维表格模型。一个关系型数据库就是由二维表及其之间的联系所组成的一个数据库 | 1.容易理解<br />2.使用方便<br />3.易于维护<br />4.支持SQL，可用于复杂的查询 | 1. 为了维护一致性付出的代价就是读写性能较差<br />2.固定的表结构<br />3.高并发读写需求<br />4.海量数据的高效率读写 |
| 非关系型数据库MongoDb、redis、HBase | 1. 使用键值对存储数据<br />2. 分布式<br />3. 一般不支持ACID特性<br />4. 非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。 | 1. 无需经过sql层的解析，读写性能很高<br />2. 基于键值对，数据没有耦合性，容易扩展<br />3. 存储格式多样，而关系型数据库只支持基础类型 | 1. 不提供sql支持，学习使用不便<br />2. 无事务处理，附加功能bi和报表等支持不好 |

##### 3. redis和mysql

- 类型上

  mysql是关系型数据库，redis是缓存型数据库

- 作用上

  mysql用于持久化的存储数据到硬盘，功能强大，但是速度较慢

  redis用于存储使用较为频繁的数据到缓存中，读取速度快

- 需求上

  需求不同，一般是配合使用



# 计算机网络

##### 1. http和https https://blog.csdn.net/cout__waht/article/details/80859369

http是超文本传输协议，https是在http协议下加了ssl层，是以安全为目标的http通道。

http传输的数据都是未加密的，也就是明文，https就是由http和ssl协议构建的可进行加密传输的身份认证的网络协议，安全性更高。但是需要ca证书，费用较高。

http端口为80，https端口为443；

http的连接很简单，是无状态的

**http的握手**：（使用tcp三次握手建立一个http连接）

1：客户端发送了一个带有SYN的Tcp报文到服务器，这个三次握手中的开始。表示客户端想要和服务端建立连接。 
2：服务端接收到客户端的请求，返回客户端报文，这个报文带有SYN和ACK标志，询问客户端是否准备好。 
3：客户端再次响应服务端一个ACK，表示我已经准备好。

3次握手过程的状态： 
listener:这个很好理解，就是服务端的某个socket处于监听状态，可以接收连接了。
syn_send:当某个socket执行connect的时候，首先发送SYN报文，因此也进入了SYN_SEND状态，并等待服务端发送过来的报文，syn_send表示客户端已发送SYN报文。 
syn_rcvd:这个状态与SYN_SEND状态差不多，表示接收了SYN报文，这个状态是服务器端的socket在建立tcp连接是的三次握手中的一个中间状态，很短暂，当客户端收到ACK报文的时候，表示连接确立，进入established状态。

(为什么是三次握手不是两次？)

假如是两次握手，客户向服务器发送请求，但是由于网络不好，很久才到达服务器，对于客户端来说这个请求已经失效了，但是服务器还是会向客户端发送确认报文。两次握手的话这时候连接已经建立，但是客户端认为请求失效，所以不会理会服务器的确认信息也不会向服务器发送确认，而服务器认为连接已经建立一直等待着客户端发送请求，于是就造成了资源的浪费。

而三次握手就防止这种情况发生，服务器没有收到客户端的确认报文，就会知道客户端没有建立连接。

（四次挥手）

1：TCP发送一个FIN，用来关闭客户到服务端的连接。 
2：服务端收到这个FIN，他发回一个ACK，确认收到序号为收到序号+1，和SYN一样，一个FIN将占用一个序号。 
3：服务端发送一个FIN到客户端，服务端关闭客户端的连接。 
4：客户端发送ACK报文确认，并将确认的序号+1，这样关闭完成。

（为什么是四次挥手）

tcp的全双工模式，接收到FIN意味着没有数据发送过来了，但是还可以继续发送数据。所以挥手的时候ack和fin分开发送

**https的握手**:（一次握手）

1. 客户端发起https请求

2. 服务端的配置（ca证书或者自己制作，其实就是公钥和私钥）

3. 传送证书（公钥，包含证书颁发机构和过期时间等信息）

4. 客户端解析证书

   这部分是客户端的TLS完成的，首先验证公钥是否有效（发现异常就弹出警告）没有问题就生成一个随机值，然后用证书对该随机值进行加密

5. 传送加密信息

   传送的是证书加密后的随机值，目的是让服务端得到这个随机值，然后客户端和服务端的通信就可以通过这个随机值来进行加密解密了

6. 服务端解密信息

   服务端用私钥解密后，得到了客户端传过来的随机值（私钥），然后把内容通过该值进行对称加密。（所以只要加密算法够变态，私钥够复杂，数据就很安全）

7. 传输加密后的信息

8. 客户端解密信息

（为什么https是安全的？）步骤468

**加密是在传输层**

##### 2. http2.0 https://segmentfault.com/a/1190000016656529?utm_source=tag-newest

| http1.x              | http2.0                |
| -------------------- | ---------------------- |
| 单向请求             | 服务器push             |
| 数据未压缩，传输量大 | 二进制传输，方便且健壮 |
| 首部信息冗余         | 首部压缩               |
| 多次连接             | 多路复用               |

多次连接：一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线也只能部分处理请求并发，但仍然会存在队列头阻塞问题。

多路复用：允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。

##### 3. GET、POST、PUT、DELETE请求 以及集中请求

https://blog.csdn.net/xiaoxiamiqianqian/article/details/91895060?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

https://blog.csdn.net/u013007900/article/details/79847741

> GET和POST的区别
>
> - 主要区别是有无幂等性，get执行一次和执行n次结果一样。
> - get可以缓存，post不能
> - get只能ASCII字符编码，数据以param的形式被编码进URL，而且有长度限制，是为了对数据进行更好的标识方便缓存。（http协议不限制url长度，浏览器限制）
> - post可以提交的数据类型很多，数据不会暴露在url中

##### 4. 浏览器渲染过程

https://www.jianshu.com/p/e6252dc9be32（浏览器渲染原理与过程）

https://baijiahao.baidu.com/s?id=1647073200474620891&wfr=spider&for=pc

浏览器将获取的HTML文档解析成DOM树。
处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。
将DOM和CSSOM合并为渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象。
渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。
将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting。



##### 5. web页面请求的全过程

**（1）准备DHCP、UDP、IP和以太网**（给bob的便携机分配IP）

> DHCP（Dynamic Host Configuration Protocol）动态主机配置协议，即插即用协议。给主机分配一个临时的IP地址，允许主机获得一些其他信息，例如子网掩码、第一条路由器地址（常称为默认网关）
>
> 四个步骤：
>
> - DHCP服务器发现。客户到达后首要任务就是发现一个DHCP服务器。于是发送一个**DHCP发现报文**，在UDP分组中向端口67发送（源端口68），源地址是0.0.0.0，目的地址是广播地址255.255.255.255
> - DHCP服务器提供。服务器收到一个发现报文，用一个**DHCP提供报文**向客户做出响应，仍然用IP广播地址255.255.255.255.报文包含收到的发现报文的事务ID、向客户推荐的IP地址、网络掩码以及IP地址租用期（通常是几小时或者几天）如果有几个DHCP服务器，该客户可以在几个地址中做选择。
> - DHCP请求。客户从一个或多个服务器提供中选择一个，并向选中的服务器提供用一个**DHCP请求报文**进行响应，回显配置参数。
> - DHCP ACK。服务器用**DHCP ACK 报文**进行响应，证实所要求的参数。

​		bob生成一个DHCP请求报文，并将报文放在dest port：67（dhcp服务器）和src port: 68（dhcp客户）的UDP报文段中，该UDP报文段被放置在具有广播IP目的地地址和源IP地址0.0.0.0的IP数据报中。

​		包含DHCP请求报文的IP数据报被放置在以太网帧，目的MAC地址：FF：FF：FF：FF：FF，使该帧将广播到与交换机连接的所有设备。

​		路由器接收到该广播以太网帧，该帧包含DHCP请求，并且从该以太网帧中抽取出IP数据报。该数据包的IP目的地指示出这个IP数据包应当由该机欸但的高层协议处理，因此该数据包的载荷（一个UDP报文段）被分解，向上到达UDP，DHCP请求报文从UDP报文段抽取出来，于是DHCP服务器有了请求报文。

​		DHCP服务器生成包含这个IP地址以及DNS服务器的IP地址，默认网关路由器的IP地址和子网块的一个DHCP　ACK报文。

​		包含DHCP　ACK的以太网帧又路由器发送给交换机（自学习），交换机知道寻址到bob的mac地址需要从哪个端口出。

​		Bob便携机接收到以太网帧，从帧里抽取IP数据报，从IP数据报中抽取UDP报文段，从UDP报文段抽取DHCP ACK报文。Bob的DHCP客户则记录下它的IP地址和它的DNS服务器的IP地址。它还在其IP转发表中安装默认网关的地址。

​		此时Bob便携机已经初始化好它的网络组件，并准备开始处理Web网页获取。

**（2）仍在准备：DNS和ARP**（获取目的网址的IP）

​		当Bob将www.google.com的url键入其浏览器时，他开启了一个长事件。

​		Bob便携机生成一个DNS查询报文，把字符串www.google.com放下DNS报文的问题段中，放置在目的端口号为53的的UDP报文段中，UDP报文段被放入到目的IP为之前DHCP ACK报文返回的DNS服务器地址的IP数据报中。

​		接下来Bob便携机要将DNS请求报文放在一个以太网帧里，目的MAC地址为网关路由器，于是Bobby需要通过**ARP协议**去获取网关路由器的MAC地址。

​		Bobby便携机生成一个具有目的IP地址为默认网关的ARP查询报文，将ARP报文放置在具有广播目的地址的以太网帧中，并向交换机发送该以太网帧，交换机将该帧交付给所有连接的设备，包括网关路由器。

​		网关路由器收到该帧，发现ARP报文中目的IP地址是它自己，于是就准备一个ARP回答，告诉Bob要找的IP地址对应的MAC地址，再由交换机传给Bob便携机。

​		Bob取出网关路由器的MAC地址后，终于可以把包含DNS查询的以太网帧寻址到路由器的MAC地址了。此时目的MAC：网关路由器，目的IP：DNS服务器

**（3）仍在准备：域内路由选择到DNS路由器**

​		网关路由器接受该帧并抽取包含DNS查询的IP数据报，查找目的地址（DNS服务器的IP），并根据转发表决定该数据应该发送到哪个路由器。最终达到DNS服务器，如果缓存了该网址的IP地址的话，则原路返回。（实际上缓存数据都是从权威DNS、顶级DNS、根DNS来的）BGP协议

**（4）Web客户-服务器交互：TCP和HTTP**

​		Bob便携机生成用于向目标网址发送**HTTP GET 报文**的TCP套接字。生成套接字的时候必须进行三次握手。Bob便携机生成一个具有目的端口为80的TCP SYN报文，将该TCP报文放置在具有目的IP地址为google的IP数据报中，将该数据报放置在目的MAC地址为网关路由器的帧中，并由交换机发送该帧。

​		包含TCP SYN的数据包到达谷歌，从数据包中取出报文，并分解到与端口80相联系的欢迎套接字。对于谷歌HTTP服务器和Bob便携机之间的TCP连接生成一个连接套接字。产生一个TCP SYNACK报文段，放入目标地址为Bob的数据报中，最后放入链路层帧，该链路适合将谷歌连接到其第一跳路由器。

​		Bob分解得到生成的TCP套接字，从而进入连接状态。

​		借助套接字Bob的浏览器生成包含要获取的URL的HTTP GET报文，该报文被写入套接字，其中GET报文成为TCP报文段的载荷。该TCP报文段放置进一个数据报中并交付到谷歌。

​		谷歌HTTP服务器从TCP套接字读取HTTPGET报文，生成一个HTTP响应报文，将i请求的web页内容放入HTTP响应体中，并将报文发送进TCP套接字中。

​		包含HTTP回答报文的数据报终于到达Bob这里，Bob的web浏览器程序从套接字读取HTTP响应，从HTTP响应体中抽取Web网页的html，终于显示了web网页。

##### 6. TCP和UDP

- TCP是面向连接的，UDP是无连接的
- TCP通过三次握手和四次挥手以及回退重传等方法提供可靠传输，UDP是尽力而为传输。
- TCP是面向字节流，UDP是面向报文的
- TCP只能是1V1，UDP可以1对多，1对1.
- TCP首部字节有20字节，UDP只有8字节。

##### 7.跨域https://juejin.im/entry/59feae9df265da43094488f6

##### 8. 安全问题XSS和CSRFhttps://yuchengkai.cn/docs/frontend/safety.html#xss

​	xss是代码注入的一种，允许恶意使用者将程式码注入到网页中，影响观看。

​	如何防御？

   - 转义字符（转义输入输出的内容，引号、尖括号、斜杠等进行转义）
   - CSP。本质上是建立白名单，规定浏览器只能执行哪些外部资源的代码Content-Security-Policy

​     CSRF利用用户的登录态发起恶意请求。挟持用户做出非本意的操作。

​     如何防御？

- Get请求不对数据进行修改
- 不让第三方网站访问用户cookie
- 组织第三方网站请求接口
- 请求时附带验证信息，比如验证码或者token

XSS利用的是用户对指定网站的信任，CSRF利用的是用户对网页浏览器的信任。

##### 9. MAC地址和IP地址

##### 10. CDN

##### 11.web重定向