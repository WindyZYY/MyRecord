《软件测试》学习笔记（自整理）

A  **crash** is when your competitor’s program dies.

When your program dies, it is an “**idiosyncrasy**”.



## 第一章 软件测试的背景

##### 1.1 软件错误用例

- 迪士尼的狮子王
- 英特尔奔腾浮点除法缺陷
- 美国航天局火星极地登陆者号探测器
- 爱国者导弹防御系统
- 千年虫问题
- 危险的预见

##### 1.2 软件缺陷是什么

- defect、failure、fault指的是确实严重的情况，甚至是危险的情况。

- anomaly、incident、variance主要指未按预料的运行，甚至是危险的情况。

- problem、error、bug比较常用

  **想怎么称呼就怎么称呼，这不是关键点**

**产品说明书（product specification)**：它对开发的产品进行定义，给出产品的细节、如何做、做什么、不能做什么。

**软件缺陷（software bug）**：

​	1.**Doesn’t do something it should do.**  

​	2.**Does something  it shouldn’t do.**  

​	3.**Does something it doesn’t mention.** 

​	4.**Doesn‘t do something it doesn’t mention but should.**  

​	5.**It’s difficult to understand, hard to use, slow, or——in the software tester's eyes——will be viewed by the end user as just plain not right.**  

**PS**：每个使用过一些软件的人都会对软件的工作方式有自己的意见和想法，要编写所有人都满意的软件是不可能的。作为软件测试员，在运用第五条测试规则时，应记住：**要全面，最重要的是要客观评价**，并非所有测试发现的缺陷都要修改。

##### 1.3 为什么会出现软件缺陷

![](pic/图片1.png)

软件缺陷产生的原因有很多，但主要原因是**产品说明书**，很多情况下，spec写的不够全面、经常更改或者小组交流不到位。其次是**设计**，程序员规划软件的过程。

##### 1.4 Software Bug的修复费用

![](pic/图片2.png)

**随着时间的推移，修复bug的费用惊人地增长**

##### 1.5 软件测试员究竟做些什么

​	● The goal of a software tester is to find bugs.

​	● The goal of a software tester is to find bugs and find them as early as possible.

​	● The goal of a software tester is to **find bugs**, find them **as early as possible**, and **make sure they get fixed**

##### 1.6 软件测试员应有的素质

What Makes a Good Software Tester?
	● relentless 
	● creative 
	● good judgment 
	● tactful and diplomatic 
	● persuasive
	●software programming
	●expert in non-computer field

好的测试员坚持不懈地追求完美。**X**

**ANS**：好的测试员知道何时完美无法企及，何时已经“够好”



## 第二章 软件开发的过程

The specifics of **what these people do**, **how they interact**, and **how they make decisions** are all part of the software development process.

- What major components go into a software product

- What different people and skills contribute to a software product

- How software progresses from an idea to a final product

##### 2.1 产品的组成部分

**产品投入：**

1. 明确客户需求

   （利用焦点人群审视软件功能）

![](pic/图片3.png)

2. Specification

   ■ The result of the customer requirements studies is really just raw data. 
   ■ It doesn't describe the proposed product, it just confirms whether it should (or shouldn't) be created and what features the customers want. 
   ■ The specifications take all this information plus any unstated but mandatory requirements and truly define what the product will be, what it will do, and how it will look.

   ■ The format of specifications varies greatly. 

3. Scheduling

![](pic/图片4.png)

**指定进度表的目的是了解哪项工作完成了，还有多少工作要做，何时全部完成**

4. Software Design Documents
   - **结构文档**。描述软件整体设计的文档，包括软件所有主要部分的描述以及相互之间的交互方式
   - **数据流图**。表示数据在程序中如何流动的正规示意图
   - **状态转换图**。表示不同状态间的转换的方式
   - **流程图**。用图形描述程序逻辑的传统方式
   - **代码注释**

5. Test Documents
   - 测试计划。描述用于验证软件是否符合产品说明书和客户需求的整体方案，包括质量目标、资源需求、进度表、任务分配、方法等。
   - 测试用例。列举测试的项目，描述验证软件的详细步骤
   - 缺陷报告。描述执行测试用例找出的问题
   - 测试工具和自动测试
   - 度量、统计和总结。

**软件产品组成部分**

![](pic/图片5.png)

**NOTICE**

- It's also important to realize that when the product is ready to be boxed up and shipped out the door, it's not just the code that gets delivered.
- Numerous supporting parts go along with it. 
- Since all these parts are seen or used by the customer, they need to be tested too.
- DON'T FORGET TO TEST ERROR MESSAGES

##### 2.2 软件项目成员

- *项目经理、程序经理或监制人员* 自始至终驱动整个项目。通常负责编写产品说明书、管理进度、进行重大决策。
- *体系架构师或者系统工程师* 是技术专家
- *程序员、开发人员或者代码制作者* 设计、编写软件并修复软件中的缺陷
- *测试员或质量保证（QA）员* 负责找出并报告软件产品的问题。
- *技术作者、用户协作专员、用户培训专员、手册编写员或者文案专员* 编制软件产品附带的文件和联机文档。
- *配置管理员或构建员* 负责把程序员编写的代码及技术作者写出的全部文档资料组合在一起，合成一个软件包。

##### 2.3 软件开发生命周期模式

**1. 大爆炸模式**

优点：简单。计划、进度安排和正规开发过程几乎没有，所有精力都花在开发软件和编写代码上。

缺点：软件已经完成，软件测试的工作其实就是报告发现的问题让客户知道。另外，产品已经完工，准备交付，测试工作越深入就会发现越来越多的软件缺陷，争吵就越多。

**尽量避开在此模式下进行测试。**

![](pic/图片6.png)

**2.边写边改模式**

“没有时间做好，但总有时间完成”  极其适用快速制作和用完就扔的小项目。

这时软件测试员将陷入无休止的循环往复，几乎每一天都会拿到新的软件版本并着手进行测试。

这种模式是最有可能碰到的，是软件开发的入门，有助于理解更加正规的方法。

![](pic/图片7.png)

**3.瀑布模式**

- 非常强调产品的定义
- 各步骤分立、没有交叉
- 无法回溯

从测试的角度：这种模式所有一切都有完整细致的说明，所有细节都确定并有文档记录，而且实现在软件中，测试小组能制定精确的计划和进度。但是因为测试仅在最后进行，**一些根本性问题可能出现在早期，但是直至准备发布产品时才可能被发现。**

![](pic/图片8.png)

**4.螺旋模式**

每一次循环都包括6个步骤：

- 确定目标、可选方案和限制条件
- 明确并化解风险
- 评估可选方案
- 当前阶段开发和测试
- 计划下一阶段
- 确定进入下一阶段的方法

![](pic/图片9.png)

**Agile software development** 敏捷软件开发

**Test-Driven Development（TDD）**

1. Test-driven is a form of development:
   1. Write test code first
   2. Do not write any production code unless tests exist
   3. Does the test determine what code needs to be written
   4. Require maintenance of a comprehensive test set

2. The basic process of test-driven development
   - Define application requirements
   - Familiarize yourself with the functional areas of the application and determine the individual functional items or functional requirements to be used
   - Create a test list of validation requirements
   - Define interfaces and classes for functions or requirements
   - Write test code
   - Run the test
   - Generate production code from the tests
   - Rerun the tests and modify the production code based on the tests until all the tests pass
   - Trim code
   - Repeat the above steps

***V-MODEL***

加强的瀑布模型，在进入下一阶段之前确认上一阶段。这种模式，在一开始软件测试就已经开始了，只要需求分析写好了。

优点：

- 在V模型中，每个阶段都有特定的可交付成果。
- 由于在生命周期的早期开发测试计划，比瀑布模型成功的几率更高。
- 与瀑布模型相比，时间关注点很低，甚至可以说少了50%。
- 适用于容易理解需求的小型项目。
- 资源的利用率很高。

缺点：

- 非常严格，就像瀑布模型。
- 灵活性小，调整范围大，难度大，成本高。
- 软件是在实现阶段开发的，因此不会生成软件的早期原型。
- V模型没有为测试阶段发现的问题提供清晰的路径。

***W-MODEL***

测试伴随着整个软件开发周期不仅要测试程序，还要测试需求、设计和功能根据W模型的要求，一旦提供了文档，就需要确定测试条件并及时编写测试用例

![](pic/图片10.png)

***H-MODEL***

软件测试不仅仅指测试的执行，还包括很多其他的活动。
软件测试是一个独立的流程，贯穿产品整个生命周期，与其他流程并发的进行。
软件测试要尽早准备，尽早执行。
软件测试是根据被测物的不同而分层进行的。不同层次的测试活动可以按照某个次序先后进行的，但也可能是反复的。

![](pic/图片13.png)

***X-MODEL***

X 测试模型的左边描述的是针对单独程序片段所进行的相互分离的编码和测试，此后将进行频繁的交接，通过集成最终合成为可执行的程序(右上半部分)，这些可执行程序还需要进行测试。
X模型中已通过集成测试的成品可以进行封版并提交给用户，也可以作为更大规模和范围内集成的一部分。
X 模型还定位了探索性测试(右下方)。

![](pic/图片12.jpg)

