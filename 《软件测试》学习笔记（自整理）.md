《软件测试》学习笔记（自整理）

A  **crash** is when your competitor’s program dies.

When your program dies, it is an “**idiosyncrasy**”.



## 第一章 软件测试的背景

##### 1.1 软件错误用例

- 迪士尼的狮子王
- 英特尔奔腾浮点除法缺陷
- 美国航天局火星极地登陆者号探测器
- 爱国者导弹防御系统
- 千年虫问题
- 危险的预见

##### 1.2 软件缺陷是什么

- defect、failure、fault指的是确实严重的情况，甚至是危险的情况。

- anomaly、incident、variance主要指未按预料的运行，甚至是危险的情况。

- problem、error、bug比较常用

  **想怎么称呼就怎么称呼，这不是关键点**

**产品说明书（product specification)**：它对开发的产品进行定义，给出产品的细节、如何做、做什么、不能做什么。

**软件缺陷（software bug）**：

​	1.**Doesn’t do something it should do.**  

​	2.**Does something  it shouldn’t do.**  

​	3.**Does something it doesn’t mention.** 

​	4.**Doesn‘t do something it doesn’t mention but should.**  

​	5.**It’s difficult to understand, hard to use, slow, or——in the software tester's eyes——will be viewed by the end user as just plain not right.**  

**PS**：每个使用过一些软件的人都会对软件的工作方式有自己的意见和想法，要编写所有人都满意的软件是不可能的。作为软件测试员，在运用第五条测试规则时，应记住：**要全面，最重要的是要客观评价**，并非所有测试发现的缺陷都要修改。

##### 1.3 为什么会出现软件缺陷

![](pic/图片1.png)

软件缺陷产生的原因有很多，但主要原因是**产品说明书**，很多情况下，spec写的不够全面、经常更改或者小组交流不到位。其次是**设计**，程序员规划软件的过程。

##### 1.4 Software Bug的修复费用

![](pic/图片2.png)

**随着时间的推移，修复bug的费用惊人地增长**

##### 1.5 软件测试员究竟做些什么

​	● The goal of a software tester is to find bugs.

​	● The goal of a software tester is to find bugs and find them as early as possible.

​	● The goal of a software tester is to **find bugs**, find them **as early as possible**, and **make sure they get fixed**

##### 1.6 软件测试员应有的素质

What Makes a Good Software Tester?
	● relentless 
	● creative 
	● good judgment 
	● tactful and diplomatic 
	● persuasive
	●software programming
	●expert in non-computer field

好的测试员坚持不懈地追求完美。**X**

**ANS**：好的测试员知道何时完美无法企及，何时已经“够好”



## 第二章 软件开发的过程

The specifics of **what these people do**, **how they interact**, and **how they make decisions** are all part of the software development process.

- What major components go into a software product

- What different people and skills contribute to a software product

- How software progresses from an idea to a final product

##### 2.1 产品的组成部分

**产品投入：**

1. 明确客户需求

   （利用焦点人群审视软件功能）

![](pic/图片3.png)

2. Specification

   ■ The result of the customer requirements studies is really just raw data. 
   ■ It doesn't describe the proposed product, it just confirms whether it should (or shouldn't) be created and what features the customers want. 
   ■ The specifications take all this information plus any unstated but mandatory requirements and truly define what the product will be, what it will do, and how it will look.

   ■ The format of specifications varies greatly. 

3. Scheduling

![](pic/图片4.png)

**指定进度表的目的是了解哪项工作完成了，还有多少工作要做，何时全部完成**

4. Software Design Documents
   - **结构文档**。描述软件整体设计的文档，包括软件所有主要部分的描述以及相互之间的交互方式
   - **数据流图**。表示数据在程序中如何流动的正规示意图
   - **状态转换图**。表示不同状态间的转换的方式
   - **流程图**。用图形描述程序逻辑的传统方式
   - **代码注释**

5. Test Documents
   - 测试计划。描述用于验证软件是否符合产品说明书和客户需求的整体方案，包括质量目标、资源需求、进度表、任务分配、方法等。
   - 测试用例。列举测试的项目，描述验证软件的详细步骤
   - 缺陷报告。描述执行测试用例找出的问题
   - 测试工具和自动测试
   - 度量、统计和总结。

**软件产品组成部分**

![](pic/图片5.png)

**NOTICE**

- It's also important to realize that when the product is ready to be boxed up and shipped out the door, it's not just the code that gets delivered.
- Numerous supporting parts go along with it. 
- Since all these parts are seen or used by the customer, they need to be tested too.
- DON'T FORGET TO TEST ERROR MESSAGES

##### 2.2 软件项目成员

- *项目经理、程序经理或监制人员* 自始至终驱动整个项目。通常负责编写产品说明书、管理进度、进行重大决策。
- *体系架构师或者系统工程师* 是技术专家
- *程序员、开发人员或者代码制作者* 设计、编写软件并修复软件中的缺陷
- *测试员或质量保证（QA）员* 负责找出并报告软件产品的问题。
- *技术作者、用户协作专员、用户培训专员、手册编写员或者文案专员* 编制软件产品附带的文件和联机文档。
- *配置管理员或构建员* 负责把程序员编写的代码及技术作者写出的全部文档资料组合在一起，合成一个软件包。

##### 2.3 软件开发生命周期模式

**1. 大爆炸模式**

优点：简单。计划、进度安排和正规开发过程几乎没有，所有精力都花在开发软件和编写代码上。

缺点：软件已经完成，软件测试的工作其实就是报告发现的问题让客户知道。另外，产品已经完工，准备交付，测试工作越深入就会发现越来越多的软件缺陷，争吵就越多。

**尽量避开在此模式下进行测试。**

![](pic/图片6.png)

**2.边写边改模式**

“没有时间做好，但总有时间完成”  极其适用快速制作和用完就扔的小项目。

这时软件测试员将陷入无休止的循环往复，几乎每一天都会拿到新的软件版本并着手进行测试。

这种模式是最有可能碰到的，是软件开发的入门，有助于理解更加正规的方法。

![](pic/图片7.png)

**3.瀑布模式**

- 非常强调产品的定义
- 各步骤分立、没有交叉
- 无法回溯

从测试的角度：这种模式所有一切都有完整细致的说明，所有细节都确定并有文档记录，而且实现在软件中，测试小组能制定精确的计划和进度。但是因为测试仅在最后进行，**一些根本性问题可能出现在早期，但是直至准备发布产品时才可能被发现。**

![](pic/图片8.png)

**4.螺旋模式**

每一次循环都包括6个步骤：

- 确定目标、可选方案和限制条件
- 明确并化解风险
- 评估可选方案
- 当前阶段开发和测试
- 计划下一阶段
- 确定进入下一阶段的方法

![](pic/图片9.png)

**Agile software development** 敏捷软件开发

**Test-Driven Development（TDD）**

1. Test-driven is a form of development:
   1. Write test code first
   2. Do not write any production code unless tests exist
   3. Does the test determine what code needs to be written
   4. Require maintenance of a comprehensive test set

2. The basic process of test-driven development
   - Define application requirements
   - Familiarize yourself with the functional areas of the application and determine the individual functional items or functional requirements to be used
   - Create a test list of validation requirements
   - Define interfaces and classes for functions or requirements
   - Write test code
   - Run the test
   - Generate production code from the tests
   - Rerun the tests and modify the production code based on the tests until all the tests pass
   - Trim code
   - Repeat the above steps

***V-MODEL***

加强的瀑布模型，在进入下一阶段之前确认上一阶段。这种模式，在一开始软件测试就已经开始了，只要需求分析写好了。

优点：

- 在V模型中，每个阶段都有特定的可交付成果。
- 由于在生命周期的早期开发测试计划，比瀑布模型成功的几率更高。
- 与瀑布模型相比，时间关注点很低，甚至可以说少了50%。
- 适用于容易理解需求的小型项目。
- 资源的利用率很高。

缺点：

- 非常严格，就像瀑布模型。
- 灵活性小，调整范围大，难度大，成本高。
- 软件是在实现阶段开发的，因此不会生成软件的早期原型。
- V模型没有为测试阶段发现的问题提供清晰的路径。

***W-MODEL***

测试伴随着整个软件开发周期不仅要测试程序，还要测试需求、设计和功能根据W模型的要求，一旦提供了文档，就需要确定测试条件并及时编写测试用例

![](pic/图片10.png)

***H-MODEL***

软件测试不仅仅指测试的执行，还包括很多其他的活动。
软件测试是一个独立的流程，贯穿产品整个生命周期，与其他流程并发的进行。
软件测试要尽早准备，尽早执行。
软件测试是根据被测物的不同而分层进行的。不同层次的测试活动可以按照某个次序先后进行的，但也可能是反复的。

![](pic/图片13.png)

***X-MODEL***

X 测试模型的左边描述的是针对单独程序片段所进行的相互分离的编码和测试，此后将进行频繁的交接，通过集成最终合成为可执行的程序(右上半部分)，这些可执行程序还需要进行测试。
X模型中已通过集成测试的成品可以进行封版并提交给用户，也可以作为更大规模和范围内集成的一部分。
X 模型还定位了探索性测试(右下方)。

![](pic/图片12.jpg)



## 第三章 软件测试的实质

##### 软件测试的实际情况

实际情况下，不可能完全符合某个model，也不可能完美地符合用户需求，也不可能有足够的时间做完需要做的所有测试。**但是，对于一个高效的软件测试员，你需要理解理想进程是什么，这样才知道目标是什么样的。**

##### 3.1 软件测试的原则

- 完全测试程序是不可能的

  > 输入量太大
  >
  > 输出结果太多
  >
  > 软件执行路径太多
  >
  > 软件说明书是主观的，可以说从旁观者来看是缺陷的

- 软件测试是有风险的

  > 软件测试员要学会的关键在于，如何把数量巨大的可能测试减少到可以控制的范围，以及如何针对风险做出明智的抉择，哪些测试重要，哪些不重要。
  >
  > **每一个软件项目都有一个最优的测试量**
  >
  > ![](pic/图片14.png)

- 测试无法显示潜伏的软件bug

  > 只能保证在你测试的范围内无bug，并不能保证软件是完美的

- 找到的软件bug越多，就说明软件bug越多

  > 原因：程序员也有心情不好的时候，程序员往往犯同样的错误，某些软件bug实乃冰山一角

- 杀虫剂怪事

  > 描述软件测试越多，其对测试的免疫力越强的现象

- 并非所有软件bug都要修复

  > 原因：没有足够的时间，不算真正的软件bug，修复的风险太大，不值得修复

- 什么时候才叫bug难以说清

  > 回顾第一章bug定义规则
  >
  > 尚未发现或未观察到的软件bug只能说是潜在bug

- 产品说明书没有最终版本

- 软件测试在产品小组终不受欢迎

  > 早点找出bug，控制情绪，不要总是报告坏消息

- 软件测试是一项讲究条理的技术专业

##### 3.2 软件测试的术语与定义

- 精确和准确

  以射飞镖为例，精确是指飞镖都在一个位置，准确是指飞镖都很接近靶心

- 确认和验证

  确认是保证软件符合spec的过程，验证是保证软件满足用户要求的过程

- 质量和可靠性

  可靠性是质量的一个方面

- 测试和质量保证

  软件测试员：尽可能早地找出所有软件bug，并确保bug得以修复。

  软件质量保证：创建和执行改进软件开发过程并防止软件缺陷发生的标准和方法
  
  SQA是管理工作，审查对象是流程，强调以预防为主
  
  测试是技术实施工作，测试对象是产品，主要是以事后检查为主
  
  SQA指导测试、监控测试，测试为SQA提供依据，是SQA的一个环节、一个手段



## 第四章 黑盒测试

##### 4.1 黑盒测试

黑盒测试又称功能测试、数据驱动测试或基于规格说明书的测试，是一种从用户观点出发的测试。

**测试人员把被测程序当作一个黑盒子**

主要检测的错误类型：

- 不正确或遗漏的功能
- 接口或界面错误
- 性能错误
- 数据结构或外部数据访问错误
- 初始化或终止条件错误等

黑盒测试对程序的功能性测试要求：

- 每个软件特性必须被一个测试用例或一个被认可的异常所覆盖
- 利用数据类型和数据值的最小集测试
- 利用一系列真实的数据类型和数据值运行，测试超负荷及其他”最坏情况“的结果
- 利用假想的数据类型和数据值运行，测试排斥不规则输入的能力
- 测试影响性能的关键模块，如基本算法、精度、时间、容量等是否正常

**优点**：

1. 有针对性地寻找问题，定位问题更精准
2. 黑盒测试可以证明产品是否达到用户的工作要求
3. 与软件实现无关，就算实现发生变化，测试用例仍然可用
4. 测试用例开发可以与软件开发同时进行，可节省软件开发时间，通过软件的用例就可以设计出大部分黑盒测试用例
5. 能重复执行相同的动作，测试工作中最枯燥的部分可交由机器完成。

**缺点**：

1.	需要充分了解待测试软件产品所用到的各项技术，测试人员需要具有较多经验。
2.	测试用例数量较大
3.	测试用例可能产生很多冗余
4.	功能性测试的覆盖范围不可能达到100%
5.	在测试过程中很多是手工测试操作。
6.	测试人员要负责大量文档、报表的编制和整理工作。

实施过程：

1. 测试计划阶段
2. 测试设计阶段：根据程序需求规格说明书或用户手册，按照一定规范化的方法进行软件功能划分和设计测试用例
3. 测试执行阶段：按照设计的测试用例执行测试；自由测试。
4. 测试总结阶段

**测试用例**：描述输入、动作、或者时间和一个期望的结果的文档，其目的是确定应用程序的某个特性是否正常的工作。其基本要素是测试用例编号、测试标题、重要级别、测试输入、操作步骤、预期结果。

##### 4.2 黑盒测试之测试用例设计技术：

- 等价类划分方法
- 边界值分析方法
- 错误推测方法
- 因果图方法
- 判定表方法

**等价类划分方法**：

是把所有可能的输入数据,即程序的输入域划分成若干部分（子集）,然后从每一个子集中选取少数具有代表性的数据作为测试用例.该方法是一种重要的,常用的黑盒测试用例设计方法.

1. 划分等价类

   等价类是指某个输入域的子集合。在该子集合中，各输入数据对于揭露程序中的错误都是等效的。**并合理地假定：测试某等价类的代表值就等于对这一类其他值的测试**所以可以划分等价类之后在每个类中取一个数据作为测试的输入条件，就可以用少量代表性的测试数据，取得较好的测试结果。

   两种不同的情况：

   - 有效等价类

     是指对于程序的规格说明来说是合理的,有意义的输入数据构成的集合。
     利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。

   - 无效等价类

     与有效等价类的定义恰巧相反。
     无效等价类指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。
     对于具体的问题，无效等价类至少应有一个，也可能有多个。

   **设计测试用例时，要同时考虑这两种等价类。因为软件不仅要能接收合理的数据，也要能经受意外的考验，这样的测试才能确保软件具有更高的可靠性**

2. 划分等价类的标准

   **完备测试、避免冗余**

   实际上是集合的划分，划分为不相交的一组子集，而子集的并是整个集合

   （并是整个集合：完备性；子集互不相交：保证一种形式的无冗余性）

3. 划分等价类的方法

   **①** 在输入条件规定了取值范围或值的个数的情况下,则可以确立一个有效等价类和两个无效等价类。
   如：输入值是学生成绩，范围是0～100

   有效类：1≤成绩≤100；无效类：成绩<0；成绩>100；

   **②** 在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下,可确立一个有效等价类和一个无效等价类。
      如  查询条件=9， 一个等于9，一个不等9

   **③** 在输入条件是一个布尔量的情况下,可确定一个有效等价类和一个无效等价类。

     如 Yes or no

   **④** 在规定了输入数据的一组值（假定n个）,并且程序要对每一个输入值分别处理的情况下,可确立n个有效等价类和一个无效等价类。
   例：输入条件说明学历可为:专科、本科、硕士、博士四种之一，则分别取这四种这四个值作为四个有效等价类，另外把四种学历之外的任何学历作为无效等价类。

   **⑤** 在规定了输入数据必须遵守的规则的情况下,可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。

   **⑥** 在确知已划分的等价类中各元素在程序处理中的方式不同的情况下,则应再将该等价类进一步的划分为更小的等价类。

4. 设计测试用例

   在确立了等价类后，可建立等价类表，列出所有划分出的等价类输入条件

   然后从划分出的等价类按以下三个原则设计测试用例：

   ①为每一个等价类规定一个唯一的编号。
   ②设计一个新的测试用例,**使其尽可能多地覆盖尚未被覆盖地有效等价类**,重复这一步，直到所有的有效等价类都被覆盖为止。
   ③设计一个新的测试用例,**使其仅覆盖一个尚未被覆盖的无效等价类**,重复这一步，直到所有的无效等价类都被覆盖为止。

**边界值分析法**

这是对等价类划分法的补充

1. 长期的测试工作经验告诉我们,大量的错误是发生在输入或输出范围的边界上,而不是发生在输入输出范围的内部.因此针对各种边界情况设计测试用例,可以查出更多的错误。

2. 与等价划分的区别

   - 边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。
   - 边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况

3. 基于边界值分析方法选择测试用例的原则

   - 如果输入条件规定了值的范围,则应取刚达到这个范围的边界的值,以及刚刚超越这个范围边界的值作为测试输入数据。

     > 例如，如果程序的规格说明中规定：“重量在10公斤至50公斤范围内的邮件，其邮费计算公式为……”。作为测试用例，我们应取10及50，还应取10.01,49.99,9.99及50.01等。

   - 如果输入条件规定了值的个数,则用最大个数,最小个数,比最小个数少一,比最大个数多一的数作为测试数据。

     > 比如，一个输入文件应包括1~255个记录，则测试用例可取1和255，还应取0及256等。

   - 将规则1）和2）应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值。

     > 例如，某程序的规格说明要求计算出“每月保险金扣除额为0至1165.25元”，其测试用例可取0.00及1165.24、还可取一0.01及1165．26等。

   - 如果程序的规格说明给出的输入域或输出域是有序集合,则应选取集合的第一个元素和最后一个元素作为测试用例。

   - 如果程序中使用了一个内部数据结构,则应当选择这个内部数据结构的边界上的值作为测试用例。

   - 分析规格说明,找出其它可能的边界条件。

**错误推测法**

基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性地设计测试用例地方法

错误推测方法的基本思想: 列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。

> 例如, 输入数据和输出数据为0的情况；输入表格为空格或输入表格只有一行. 这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例。 

**因果图方法**

考虑输入条件之间的相互组合,可能会产生一些新的情况. 但要检查输入条件的组合不是一件容易的事情, 即使把所有输入条件划分成等价类,他们之间的组合情况也相当多. 因此必须考虑采用一种适合于描述对于多种条件的组合,相应产生多个动作的形式来考虑设计测试用例。这就需要利用因果图（ Cause一Effect Graphics ）方法。
采用因果图方法能够帮助我们按一定步骤，高效率地选择测试用例，同时还能为我们指出，程序规格说明描述中存在着什么问题。 

![](pic/图片15.png)

###### 左节点表述输入状态（原因），右节点表示输出状态（结果）

输入状态相互之间还可能存在某些依赖关系，称为约束。在因果图中用特定的符号表示。

> - 输入条件的约束有以下4类：
>
> ① E约束（异）：a和b中至多有一个可能为1，即a和b不能同时为1。
>
> ② I约束（或）：a、b和c中至少有一个必须是1，即 a、b 和c不能同时为0。
>
> ③ O约束（唯一）；a和b必须有一个，且仅有1个为1。
>
> ④R约束（要求）：a是1时，b必须是1，即不可能a是1时b是0。
>
> - 输出条件约束类型
>
> 输出条件的约束只有M约束（强制）：若结果a是1，则结果b强制为0。

因果图最终生成地是判定表。适合于检查程序输入条件的各种组合情况。

> **利用因果图生成测试用例的基本步骤:**
>
> (1) 分析软件规格说明描述中, 那些是原因(即输入条件或输入条件的等价类),那些是结果(即输出条件), 并给每个原因和结果赋予一个标识符。
>
> (2) 分析软件规格说明描述中的语义.找出原因与结果之间, 原因与原因之间对应的关系. 根据这些关系,画出因果图。
>
> (3) 由于语法或环境限制, 有些原因与原因之间,原因与结果之间的组合情况不不可能出现. 为表明这些特殊情况, 在因果图上用一些记号表明约束或限制条件。
>
> (4) 把因果图转换为判定表。
>
> (5) 把判定表的每一列拿出来作为依据,设计测试用例。

因果图方法是一个非常有效的黑盒测试方法，它能够生成没有重复性的且发现错误能力强的测试用例，而且对输入、输出同时进行了分析。

**判定表驱动测试方法**

判定表通常由4个部分组成：

![](pic/图片16.png)

- 条件桩（Condition Stub）:列出了问题的所有条件，通常认为列出得条件的次序无关紧要。
- 动作桩（Action Stub）:列出了问题规定可能采取的操作，这些操作的排列顺序没有约束。
- 条件项（Condition Entry）:列出针对它左列条件的取值，在所有可能情况下的真假值。
- 动作项（Action Entry）:列出在条件项的各种取值情况下应该采取的动作。
- 规则:任何一个条件组合的特定取值及其相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。显然,判定表中列出多少组条件取值,也就有多少条规则,既条件项和动作项有多少列。

![](pic/微信图片_20191009173457.png)

> 判定表的建立步骤：
>
> ①确定规则的个数.假如有n个条件。每个条件有两个取值（0,1）,故有2n种规则。
>
> ②列出所有的条件桩和动作桩。
>
> ③填入条件项。
>
> ④填入动作项。等到初始判定表。
>
> ⑤简化.合并相似规则（相同动作）。



## 第五章 白盒测试

##### 5.1 白盒测试概念

​		白盒测试也称**结构测试**和**逻辑驱动测试**，是一种测试用例设计方法，它从程序的控制结构导出测试用例。

​		白盒测试使用被测单元内部如何工作的信息，允许测试人员对程序内部逻辑结构及有关信息来设计和选择测试用例，对程序进行测试

​		**基本要求**：

- 保证一个模块中的所有独立路径都至少被执行一次；
- 对所有的逻辑值均需要测试真、假两个分支；
- 在上下边界及可操作范围内运行所有循环；
- 检查内部数据结构以确保其有效性。

##### 5.2 测试覆盖标准

白盒测试考虑的是测试用例对程序内部逻辑的覆盖程度，**希望覆盖的程度尽可能高些**

**语句覆盖<判定覆盖（分支覆盖）<条件覆盖<判定/条件覆盖<条件组合覆盖**

![1576479153737](C:\Users\WindyZYY\AppData\Roaming\Typora\typora-user-images\1576479153737.png)

###### 自己的理解：语句覆盖就是保证每个可执行语句至少执行一次；分支覆盖是每个判断的真假分支至少执行一次；条件覆盖是指判定中的每个条件的每个可能取值都要执行一次；判定/条件覆盖=分支+条件；条件组合覆盖是每个条件的可能取值的自由组合都要执行一次。

##### 5.3 综合策略——黑盒法补充测试用例

​		即使达到任何一种覆盖标准，其测试效果仍然是不彻底的，还需要其他的测试方法作补充。

​		![1576481791859](C:\Users\WindyZYY\AppData\Roaming\Typora\typora-user-images\1576481791859.png)

##### 5.4 基本路径测试

​	白盒测试的主要方法，一是逻辑驱动测试，包括5种覆盖，另一种就是路径测试

​	**路径测试就是设计足够多的测试用例，覆盖被测试对象中的所有可能路径**（路径的自由组合）

​	但是一般路径都是一个庞大的数字，为了解决这个问题，必须把覆盖的路径数压缩到一定的限度内→**基本路径测试**：它在程序控制图的基础上，通过分析控制构造的环形复杂性，导出基本可执行路径集合，从而设计测试用例（要保证测试中程序的每一个可执行语句至少执行一次）

> **4个步骤：**
>
> 程序的控制流图
>
> 程序圈复杂度：V(G) = E-N+2（E是边，N是节点）V(G) = P+1（P是判定节点的数量）
>
> 导出测试用例
>
> 准备测试用例
>
> **一个方法**
>
> 图形矩阵：有点像有向图的邻接矩阵。如果一行都两个或者多个1，那么这行对应的节点是判定节点。

由边和结点限定的范围称为区域（包括图外部的范围）



### 第六章 静态测试

##### 6.1 静态测试概念

通过检查和评审软件而**不是运行软件**对软件进行测试的方法，可以手工进行，也可以借助软件工具自动进行

测试对象：与软件相关的需要测试的产品，如各类文档、源代码等

> 为什么需要？
>
> 1. 静态测试的成效最多能识别50%-60%的缺陷，动态最多40%-50%
>
> （这是有效静态测试的结果，无效静态测试基本没有效果
>
> 2. ![1576485455980](C:\Users\WindyZYY\AppData\Roaming\Typora\typora-user-images\1576485455980.png)

##### 6.2 静态测试技术的特点

- 静态测试不需要动态的运行程序，也就不必进行测试用例的设计和结果判读等工作
- 可以人工进行
- 不需要特别的条件，容易开展

##### 6.3 静态测试包括的内容

- 主要由人工进行的

  - 代码审查

  - 代码走查

    （上面两个的优点：1. 一旦发现错误，就知道错误的性质和位置，调试花费代价低 2. 一次能解释一批错误）

  - 桌面检查（程序员自己检查，因为偏爱/思维定势/设计出错，效率不高）

- 主要由软件工具自动进行的静态分析

- 广义上，还包括软件需求分析和设计阶段的技术评审

  **代码审查**

  > **代码审查**
  >
  > 检查代码和设计的一致性
  >
  > 检查代码对标准的遵循、可读性
  >
  > 检查代码的逻辑表达的正确性
  >
  > 检查代码结构的合理性
  >
  > **四个步骤**
  >
  > 1. 准备
  >
  >    组长提前把程序目录表和设计说明书等材料分配给小组成员
  >    小组成员熟悉这些材料
  >    由被测程序的设计和编码人员向审查组详细说明所准备的材料，特别是代码的主要功能与功能间的关系程序阅读
  >
  > 2. 程序阅读
  >
  >    对照代码审查单标出明显缺陷及错误
  >
  > 3. 审查会
  >
  >    组长负责讨论沿着建设性的方向前进，而其他人则集中注意力发现错误，但不去纠正错误
  >
  > 4. 跟踪及报告
  >
  >    会后把发现的错误登记造表并交给程序开发人员
  >    如果发现错误较多或发现重大错误，那么在改正之后，组长要再次组织审查会议
  >    为了改进以后的审查工作，对错误登记表也要分析，归类和精炼

  > **通用代码审查清单**
  >
  > - 数据应用错误（使用未经正确声明和初始化的变量、常量、数组、字符串或记录而导致的软件缺陷）缓存区溢出地主要原因
  > - 数据声明错误（不正确地声明或使用变量和常量）
  > - 计算错误（实际上是糟糕地数学问题，计算无法得到预期结果）
  > - 比较错误（很可能是边界条件问题）
  > - 控制流程错误（编程语言中循环等控制结构未按预期方式工作）（通常由比较错误或计算错误直接或间接造成）
  > - 子程序参数错误（软件子程序不正确地传递数据）
  > - 输入输出错误（包括文件读取、接受键盘或者鼠标输入以及向打印机或者屏幕等输出设备写入错误
  > - 其他检查（这不是为了完整，而是提示为定制软件项目清单应该加入的内容
  
  

  > **代码走查**
  >
  > 和审查类似，只是程序和错误检查技术不完全相同
  >
  > 在会议上对每个测试用例用头脑来执行程序，也就是用测试用例沿程序逻辑走一遍
  >
  > 测试用例不是关键，这里是作为怀疑程序逻辑与计算错误的启发点，在随测试实例遍历程序逻辑时，在怀疑程序的过程中发现错误
  >
  > 但是由于人们注意力会相对集中在随测试用例遍历得程序逻辑路径上，不如代码审查检查的范围广，错误覆盖面全

  > **需求定义的高级审查**
  >
  > 对需求定义的测试着重于测试对用户需求的描述和解释是否完整、准确
  > 高级审查：测试需求定义的第一步是站在一个高度上进行审查，找出根本性的问题、疏忽或遗漏之处
  > 低层测试：高级审查之后可以很好地了解产品以及影响其设计的外部因素，然后就可以在更低的层次测试需求定义了。

  > 软件质量因素分组：1. 完备性  2.一致性  3.正确性  4. 可行性  5.易修改性  6. 健壮性  7. 易追溯性  8.易理解性  9. 易测试性和可验证性   10. 兼容性

  > **设计文档的静态测试**
  >
  > 对设计文档的静态测试着重于:
  >
  > - 分析设计是否与需求定义一致
  > - 所采用的数值方法和算法是否适用于待解问题
  > - 程序的设计中对程序的划分是否与待解问题相适应
  > - 需求是否都被满足了

  > **源代码的静态测试**
  >
  > 着重于对源代码的静态测试着重于分析实现是否正确、完备





### 第七章 单元测试

##### 7.1 单元测试基本概念

​	“单元”：明确的功能、规格定义，与其他部分明确的接口定义。

​	单元测试：也叫模块测试，这是针对最小的可测试软件元素-模块进行测试工作，目的在于发现各模块内部可能存在的各种差错。

	单元测试的依据是详细设计描述。
​	单元测试的内容包括单元的内部结构（如逻辑和数据流）以及单元的功能和可观测的行为。
​	通常，我们使用白盒测试方法测试单元的内部结构，使用黑盒测试方法测试单元的功能和可观测的行为。

##### 7.2 单元测试环境

​	自底向上（Driver）：所测模块的主程序：它接收测试数据，把这些数据传递给所测试模块，最后再输出实测结果。当被测试模块能完成一定功能时，也可以不要驱动模块

​	自顶向下（Stub）：用来代替所测模块调用的子模块。

![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\80Y}V92C3JR13%1PO2CYQV7.png)

##### 7.3 单元测试内容

![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\)VQO1_VSX~27B4UUANL1{PL.png)

- 模块接口测试

  是单元测试的基础，只有在数据能正确流入、流出模块的前提下，其他测试才有意义

- 局部数据测试

  是为了保证临时存储再模块内的数据在程序执行过程中完整、正确。

  局部数据结构往往是错误的根源，要仔细检查：不合适或者不相容的类型说明，变量无初值，变量初始化或缺省值错误，不正确的变量名，出现上溢、下溢和地址异常

- 独立路径测试

  全局数据对模块的影响，在模块中应对每一条独立执行路径进行测试，此时设计测试用例是为了发现因错误计算、不正确的比较和不适当的控制流造成的错误。

  **基本路径循环和循环测试**是最常用且最有效的测试技术

- 错误处理测试

- 边界条件测试

##### 7.4 单元测试用例的设计思路

	测试用例的设计根据是详细设计文档进行：
- 为系统运行设计用例
  	用最简单的方法执行被测单元。
- 为正向测试设计用例
  	测试设计说明书所对应的功能项或性能指标是否达到。
- 为逆向测试设计用例
  	测试被测单元有没有做它不应该做的事情。

- 为满足特殊需求设计用例
  	从系统的性能、安全性、保密性的角度来设计测试用例。
- 为代码覆盖设计用例
  	保证较高的代码测试覆盖率。
- 为覆盖率指标完成设计用例
  	对于复杂的判定条件，循环以及分支语句，在执行测试的过程中，覆盖率指标没有达到，分析原因可能有：
  - 不可能的路径或分支
  - 不可能或冗余的代码
  - 不充分的测试用例

##### 7.5 单元测试的过程

![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\YT7{7`2EHF(D73}PQ}H4Z4S.png)



### 第八章 集成测试

##### 8.1 集成测试的基本概念

集成测试又称组装测试，是在单元测试的基础上，将所有模块按照设计要求组装成子系统或系统进行的测试活动。

##### 8.2 集成测试的内容

确保各单元组合在一起后能够按既定意图协作运行，并确保增量的行为正确，所测试的内容包括单元间的接口以及集成后的功能。

**具体需要考虑以下问题：**

1. 在把各个模块连接起来的时候，穿越模块接口的数据是否会丢失；
2. 各个子功能组合起来，能否达到预期要求的父功能；
3. 一个模块的功能是否会对另一个模块的功能产生不利的影响；
4. 全局数据结构是否有问题
5. 单个模块的误差积累起来，是否会放大，从而达到不可接受的程度。

##### 8.3 集成测试的优点

•单元测试具有不彻底性，对于模块间接口信息内容的正确性、相互调用关系是否符合设计无能为力。只能靠集成测试来进行保障。

•同系统测试相比，由于集成测试用例是从程序结构出发的，目的性、针对性更强，测试项发现问题的效率更高，定位问题的效率也较高；

•能够较容易地测试到系统测试用例难以模拟的特殊异常流程，从纯理论的角度来讲，集成测试能够模拟所有实际情况；

•定位问题较快，由于集成测试具有可重复强、对测试人员透明的特点，发现问题后容易定位，所以能够有效地加快进度，减少隐患。

##### 8.4 集成测试的层次

1. 模块内集成测试
2. 子系统内集成测试
3. 子系统间集成测试

##### 8.5 集成测试方法

1. 静态测试——针对概要设计的测试

2. 动态测试——灰盒测试

   > 灰盒测试的优点：
   >
   > • 能够进行基于需求的测试和基于路径的覆盖测试。
   >
   > • 可深入被测对象的内部，便于错误的识别分析和解决。
   >
   > • 能够保证设计的黑盒测试用例的完整性，防止功能或功能组合的遗漏
   >
   > • 能够减小需求或设计不详细或不完整性对测试有效性造成影响。 

##### 8.6 集成策略

​	指在测试对象分析基础上，**描述软件模块集成的方式、方法**

- 非增量式集成策略——一步到位

  对所有模块进行个别的单元测试后，按照程序结构图将各模块连接起来，把连接后的程序当作一个整体进行测试。**Big Bang**

  优点：①方法简单  ②允许多测试人员同时并行工作，人力物力资源利用率较高

  缺点：①必须为每个模块准备相应的驱动模块和桩模块，测试成本较高  ②一旦集成后包含多种错误，难以纠正。

- 增量式集成策略——逐步实现

  逐次将未曾集成测试的模块和已经集成测试的模块（或子系统）结合成程序包，再将这些模块集成为较大系统，在集成的过程中边连接边测试，以发现连接过程中产生的问题。

  - 自顶向下增量式测试

    > （1）主控模块作为测试驱动器。
    > （2）根据集成的方式（深度或广度），下层的桩模块一次一次地被替换为真正的模块。
    > （3）在每个模块被集成时，都必须进行单元测试。重复第2步，直到整个系统被测试完成。
    >
    > 优点：
    > 	较早地验证了主要控制和判断点；
    > 	按深度优先可以首先实现和验证一个完整的软件功能；
    > 	功能较早证实，带来信心；
    > 	只需一个驱动，减少驱动器开发的费用；
    > 	支持故障隔离。
    >
    > 缺点：
    > 	桩的开发量大；
    > 	底层验证被推迟；
    > 	底层组件测试不充分。
    >
    > 适用范围：
    >
    > ​	产品控制结构比较清晰和稳定；
    > ​	高层接口变化较小；
    > ​	底层接口未定义或经常可能被修改；
    > ​	产口控制组件具有较大的技术风险，需要尽早被验证；
    > ​	希望尽早能看到产品的系统功能行为。

  - 自底向上增量式测试

    从具有最小依赖性的底层组件开始，按照依赖关系树的结构，逐层向上集成，以检验系统的稳定性.

    > （1）起始于模块依赖关系树的底层叶子模块，也可以把两个或多个叶子模块合并到一起进行测试
    > （2）使用驱动模块对步骤１选定的模块（或模块组）进行测试
    > （3）用实际模块代替驱动模块，与它已测试的直属子模块组装成一个更大的模块进行测试
    > （4）重复上面的行为，直到系统最顶层模块被加入到已测系统中
    >
    > 优点：
    > 	对底层组件行为较早验证；
    > 	工作最初可以并行集成，比自顶向下效率高；
    > 	减少了桩的工作量；
    > 	能较好锁定软件故障所在位置。
    >
    > 缺点：
    >
    > ​	驱动的开发工作量大；
    >
    > ​	对高层的验证被推迟，设计上的错误不能被及时发现。
    >
    > 适用范围：
    > 	适应于底层接口比较稳定；
    > 	高层接口变化比较频繁；
    > 	底层组件较早被完成。

  - 三明治增量式测试（混合）

    把系统划分成三层，中间一层为目标层，目标层之上采用自顶向下集成，之下采用自底向上集成

    ![1576603244367](C:\Users\WindyZYY\AppData\Roaming\Typora\typora-user-images\1576603244367.png)

    > 优点：
    >
    > ​	集合了自顶向下和自底向上两种策略的优点
    >
    > 缺点：
    >
    > ​	中间层测试不充分
    >
    > 适用范围：
    >
    > ​	适应于大部分软件开发项目 



### 第九章  单元测试框架

主要是了解JUnit的使用

![1576724466702](C:\Users\WindyZYY\AppData\Roaming\Typora\typora-user-images\1576724466702.png)

失败与错误 ：JUnit框架区别失败与错误。
		“出现“失败”的断言通常表示产品代码中有问题
		而出现“错误”却表示测试本身或周围的环境存在着问题。

 		有时候，JUnit框架的“失败”被称为“预期的失败条件”；而“错误” 被称为“不曾预料到的失败条件”。然而“错误”，即“不曾预料到的失败条件”，在运行时候（runtime）将引起异常。 

**建议先调查“错误”**，解决了错误问题以后再重新运行这个测试。  



### 第十章  系统测试

##### 10.1 系统测试的概念





### 第十五章  软件测试计划

##### 15.1 测试计划的目标

​	软件测试计划——是软件测试员与产品开发小组交流意图的主要方式

​	测试计划的目标是：规定测试活动的范围、方法、资源和进度； 明确正在测试的项目、要测试的特性、要执行的测试任务、每个任务的负责人，以及与计划相关的风险。

​	测试计划过程的最终目标是交流（而不是记录）软件测试小组的意图、期望，以及对将要执行的测试任务的理解。

##### 15.2 测试计划主题

- 高级期望

  不仅测试人员要清楚，还要保证程序员、文档编写人员、管理部门都要知道，因为要获得他们的同意和支持

  - 测试的是什么产品
  - 产品的质量和可靠性目标是什么

- 人、地点和事

  - 明确在项目中工作的人，他干什么，怎么样与他联系

- 定义

  - 软件缺陷的定义（5条）
  - 构造：程序员放在一起需要测试的代码和内容的搜集
  - 测试发布文档：程序员发布的文档
  - Alpha版：意在对少数主要客户和市场进行数量有限的分发，用于演示目的的早期构造。使用alpha版的所有人必须了解其确切内容和质量等级。
    Beta版：意在向潜在客户广泛分发的正式构造。进行beta测试的原因需要定义。
  - 说明书完成：说明书预计完成并且不再更改的日程安排。虽然不可能非常精确，但是它确实应该设定，以后只能进行控制范围内的小改动。
    特性完成：程序员不再向代码增加新特性，并集中修复缺陷的日期安排。
    软件缺陷会议：由测试经理、项目经理、开发经理和产品支持经理组成的团队，每周召开会议审查软件缺陷，并确定哪些需要修复，应该如何修复。软件缺陷会议是在测试计划中建立质量和可靠性目标的主要措施之一。

- 团队之间的责任

- 哪些需要测试，哪些不需要

  - 如果某部分不要测试，需要阐明理由，因为这是**风险**

- 测试的阶段

  - 进入和结束

- 测试策略

  - 使用何种技术

- 资源需求

- 测试员的任务分配

- 测试进度

  - 测试进度非常重要，有时甚至会根据测试进度决定砍掉产品的一些特性，或者推迟到下一版本中推出。
  - 测试工作的进度安排通常都不是平均分布的，因为测试任务的数量、人员的数量和测试花费的时间随着项目的进展不断增长，在产品发布之前会形成短期的高峰。
  - 持续增长的结果是测试进度受到先前事件的影响越来越大。即产生进度破坏的问题。
  - 有效的解决进度破坏问题的方式是：避免定死启动和停止任务的时间。

- ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\~E8Y@8M6}}I[L1T~9S[H]$O.png)



##### 15.3 测试策略

考虑问题：测试范围、测试方法、测试标准、测试工具

1. 确定测试范围

   不能仅仅由测试人员来确定。

   测试过度会在测试覆盖中存在大量冗余，范围过小，则存在一楼错误的风险

   需要考虑：首先测试最高优先级的需求，测试新的功能和代码或者改进旧功能，使用等价类来减小测试范围，重点测试经常出问题的地方

   通过提问单来确定测试范围

2. 选择测试方法

   ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\}JLG5LNWOPB_[%L`93W$X%Y.png)

3. 定义测试标准

   - 测试入口标准
   - 测试出口标准
   - 测试暂停与继续标准

   常用规则：

   - ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\UHYW11~`C_JV$]F4D8ULP00.png)
   - ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\FOWM@L]0I]@]%4`E9JI3O1E.png)
   - ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\ZI_Q`0[BZDKYGQOMDUAZZZX.png)
   - 选择自动化测试工具

4. 测试环境

   计算机平台、操作系统、浏览器、软件支持平台、外部设备、网络环境、其它专用设备

5. 测试管理

   主要考虑：

   - 选择缺陷管理工具和测试管理工具

   - 定义工作进度

     ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\ASX1D`M6L_W]I1$~Q45RI`D.png)

     - 确认工作任务

       工作任务可以分为两类，一类是可以直接和需求文档对应起来的，另外一类和需求文档没有直接的关联。
       在需求文档中，描述了软件的功能性需求和非功能性需求，对需求中的每一个条目，都应该有相应的测试工作与之对应起来。 
       确认好测试任务后，还应该排列这些任务的优先级。 

     - 估算工作量

       测试工作量的估算可以采用以下方法：
       	建立详细的工作分解结构 
       	分析以往项目，寻找历史数据
       	使用评估模型

     - 编写进度计划

       可使用甘特图来进行表示

   - 建立风险管理计划

     识别风险、评估风险、制定对策、跟踪风险

   ##### 15.4 测试计划编写

   测试计划是描述软件测试努力的目标、范围、方法和焦点的文档

   

   

   ### 第十六章  软件缺陷管理

   ##### 16.1 软件缺陷概述

   >  软件未达到软件规格说明书中规定的功能；
   >  软件超出软件规格说明书中指明的范围；
   >  软件未达到软件规格说明书中指出的应达到的目标；
   >   软件运行出现错误；
   >  软件测试人员认为软件难于理解，不易使用，运行速度慢，或者最终用户认为软件使用效果不好。

   o软件缺陷（Defect），常常又被叫做Bug。

   o所谓软件缺陷，即为计算机软件或程序中存在的**某种破坏正常运行能力的问题、错误，或者隐藏的功能缺陷**。

   **缺陷的属性：**

   - 主要：identifier、type、severity、priority、status、origin、source、root cause
   - 其他：summary、description、owner/assignee、found in、fixed in、resolution、verified in、attachment

   **缺陷的分类：**

   - 缺陷的类型

     ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\WYT44B_9[C1V98OCWD{DWIR.png)

   - 严重程度

     ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\IG5FIOBOUQKX8PZD{D{X}O8.png)

   - 优先级

     ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\06}_06$B`_Q`UIU74@`42OO.png)

   - 状态

     ![1576657883717](C:\Users\WindyZYY\AppData\Roaming\Typora\typora-user-images\1576657883717.png)

   - 起源

     ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\}YFUB@I7LEOUV5HE21~1G7S.png)

   - 来源

     ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\D{%6JKGQ_{ZDP`N6`S]3R@0.png)

   - 根源

     ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\XFEMOO6`4BSB{$IT43~]]}F.png)

   ##### 16.2 如何报告缺陷

   1. 如何面对软件缺陷

      确保发现的bug全部被关闭，但**不一定被修复**（原因）

   2. 如何有效描述缺陷

      - 尽早报告bug

        ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\5GOZF40INZ%I2PQ~@`{80%C.png)

      - 有效描述

        ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\[O6B41%$G8ZXUG8YSD7T@XS.png)

      - 缺陷描述的三个部分

        概要、再现步骤、隔离（隔离是指测试员用来确认错误是一个真正的问题，并识别哪些影响错误表现的因素而收集的结果和信息）

   ##### 16.3 如何跟踪缺陷

   - 使用状态来管理缺陷生命周期

     不是每个组织都采用相同的缺陷生命周期，定义的缺陷的状态不完全相同

     ![1576658534189](C:\Users\WindyZYY\AppData\Roaming\Typora\typora-user-images\1576658534189.png)

     软件bug处理流程及状态变化

     ![1576658638423](C:\Users\WindyZYY\AppData\Roaming\Typora\typora-user-images\1576658638423.png)

   - 强调所有权和责任

     - 谁负责设置和改变bug的状态
     - 使用分配和估计修复日期跟踪缺陷修复
     - 跟踪测试人员所有权，尽快完成回归测试

   - 关键转移

     ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\GQ@D]K6`QC]]0M2YC`~6J@R.png)

   ##### 16.4 缺陷度量

   缺陷度量：帮助确定产品缺陷分布的情况、 帮助确定产品缺陷分布的情况“概率”和“风险发生后所带来的损失”来评估风险。 

   - 测试有效性度量分类

     ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\UYG2O}$~V5NNF8OP6K5GBP5.png)

   - 缺陷度量

     - 数量

       所有的bug并不都是均等的（加权分等级）最初存在的数量对发现的bug数量有着重要的正影响

     - 产品缺陷

       在产品中或客户发现的缺陷数量，测试员没有发现的或者是在发布之前未修复的

     - 缺陷消除率（DRE）

       ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\F4X39RD}1J_1~9}YFO$H4AU.png)

       ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\945$JD~9F_WYO9_EUZDDJE5.png)

     - 缺陷潜伏期

       发现时间越晚，带来的损害就越大

       ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\YL@OP]R3SUG4CR_XG$M_R2I.png)

       ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\UW8~Z[HS4HK@K[J8XAC~UIE.png)

     - 缺陷损耗

       ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\(7]_L)CM6A$]~M88OQNO1K3.png)

       ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\GG4WBUMX%{DRW_{`2EF4YAD.png)

     - 缺陷密度

       **缺点密度 = 缺陷数量/代码行或功能点的数量**

       Pareto分析

   ##### 16.5 缺陷管理工具

   ​	IBM Rational ClearQuest, BugFree. HP TestDirector

   

   

   ### 第十七章  软件配置管理

   ##### 17.1 定义

   software configuration management， SCM是软件工程中用来管理软件资产变更的一项规程，包括它所使用的相关工具和应用技术（IEEE）

   协调软件开发是的混乱减到最小的技术（Wayne Babich）

   软件配置管理是指通过执行版本控制、变更控制等规程，以及使用合适的配置管理软件，来保证所有配置项的完整性和可跟踪性。配置管理是对工作成果的一种有效保护。 

   ##### 17.2 基本概念

   配置项：凡是纳入配置管理范畴的工作成果统称为配置项（Configuration Item，CI）。主要有两大类：

   - 属于产品组成部分的工作成果，例如源代码、需求文档、设计文档、测试用例等等。

   - 在管理过程中产生的文档,例如各种计划、监控报告等等，这些文档虽然不是产品的组成部分，但是值得保存。 

     每个配置项的主要属性有：名称、标识符、文件状态、版本、作者、日期等

   基线：由一组配置项组成，这些配置项构成了一个相对稳定的逻辑实体。

   ​	基线的主要属性：名称、标识符、版本、日期等

   ​	通常交互给客户的基线称为一个release，为内部开发用的基线则称为一个build

   角色：

   ​	配置管理员的主要工作是为项目指定配置管理计划，创建和维护配置库等

   ​	大型项目，还需要CCB。在配置管理而言，CCB是决策者，配置管理员是执行者。

   ​	小型项目，让项目经理或者配置管理员做决定就好了

   ##### 17.3 配置计划：

   ​	根据项目的规模和时间周期等，定义相应的配置管理活动、配置审计和报告

   ##### 17.4 配置审计和报告

   ![1576668798462](C:\Users\WindyZYY\AppData\Roaming\Typora\typora-user-images\1576668798462.png)

   SCM从应用层次可以从低到高分为三级：版本控制、以开发者为中心、过程驱动



### 第十八章  软件维护

##### 18.1 软件维护的定义

软件维护是指软件系统**交付使用**以后，为了改正错误或满足新的需要而修改软件的过程。

要求进行维护的原因：

- 改正程序中的错误和缺陷
- 改进设计以设计新的软、硬件环境
- 增加新的应用范围

##### 18.2 软件维护的类型

- 改正性维护（修复bug）

  在软件交付使用后，因开发时测试的不彻底、不完全，必然会有部分隐藏的错误遗留到运行阶段。

  改正性维护就是为了识别和纠正软件错误、改正软件性能上的缺陷、排除实施中的误使用，应当进行的诊断和改正错误的过程

- 适应性维护（提升可适应性）

  在使用过程中，外部环境（新的硬件、软件配置）、数据环境（数据库、数据格式、数据输入/输出方式、数据存储介质）可能发生变化。
  为使软件适应这种变化，而去修改软件的过程就叫做适应性维护。

- 完善性维护（增加功能）

  在软件的使用过程中，用户往往会对软件提出新的功能与性能要求。
  为了满足这些要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。这种情况下进行的维护活动叫做完善性维护。

- 预防性维护（提高性能）

  预防性维护即软件再工程，是为了提高软件的可维护性、可靠性等，为以后进一步改进软件打下良好基础。

  采用先进的软件工程方法对需要维护的软件或软件中的某一部分（重新）进行设计、编制和测试，称为预防性维护。

软件维护的特点：结构化维护和非结构化维护差别巨大，软件维护的代价高昂，维护问题多

- 结构化维护VS非结构性维护

  ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\C0HN42GR5~898R]KACL@DQK.png)

  非结构性维护代价大，结构性维护有利于减少工作量和降低成本，大大提高软件的维护效率

- 软件维护的代价

  维护费用只不过是软件维护最明显的代价，其他一些还不明显的代价将来可能更为人们关注，其他无形代价还有：可用的资源被软件维护占用，未能及时满足用户的维护要求时引起用户不满等

  用于维护工作的劳动可以划分为：生产性劳动（分析代码、修改设计、编写程序代码等）非生产性活动（理解程序代码功能、解释数据结构、接口特点、性能限度等）

  维护工作量的模型：

  ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\JI8NABD$G[UZVFPP2P7C0JF.png)

- 软件维护的问题

  与软件维护有关的大多数问题都可归因于软件定义和开发方法上的不足。

  - 理解别人的代码很难
  - 没有合格的文档
  - 不能指望开发人员仔细说明软件
  - 绝大多数软件在设计时没有考虑到未来的修改，可能导致修改软件既困难又容易发生差错
  - 软件维护不是一个吸引人的工作

##### 18.3 影响软件维护工作量的因素

- 系统的大小
- 程序设计语言
- 系统年龄
- 数据库技术的应用
- 先进的软件开发技术
- 其他一些因素

##### 18.4 软件维护的过程

由于在软件的运行过程中，需要不断地进行修改和完善，维护工作量逐年上升。
软件维护过程与软件类型、软件开发过程以及人员因素有着密切的关系

软件维护过程由一系列变更请求触发。
变更请求可能来自系统用户、管理层或者客户。对变更请求经过成本和影响分析评估，一旦变更请求获得批准，就要对系统规划一个新版本，然后实现这个变更。

软件维护工作在维护申请提出之前就开始了，它包括：

- 建立维护组织，强制报告和评估的过程；

  ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\M69O$1RO23R0$]Q8GPB%IK4.png)

  在维护人员对程序进行修改的过程中，由配置管理员严格把关，控制修改的范围，对软件配置进行审计 。

  分为短期团队和长期团队。都要把有经验的员工和新员工混合起来。

- 为每个维护申请确定标准化的事件序列；

  维护申请表、维护修改报告（满足维护请求表中提出的要求所需的工作量、维护要求的性质、维护要求的优先次序、与修改有关的背景数据）

  ![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\KWJP~YW`%9TREHD}JR71Y39.png)

  维护工作最后一步是复审，主要审查修改过的软件配置，以验证软件结构中的所有成分的功能，保证满足维护请求表中的要求。

- 制定保存维护活动记录的制度和有关复审及评估的标准。

  情况复审的目的在于促进未来的维护工作,同时也为有效管理软件组织提供重要的反馈信息。

![1576671336743](C:\Users\WindyZYY\AppData\Roaming\Typora\typora-user-images\1576671336743.png)

![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\F(7ZKJVLR[)[ZZ1L$UY2I@J.png)

##### 18.5 软件维护副作用

- 代码副作用

  修改代码将使编码更加混乱，程序结构更不清晰，可读性更差，而且有连锁反应。

  - 修改或删除子程序;
  - 修改或删除语句标号;
  - 修改或删除标识符;
  - 为提高执行效率而做的修改;
  - 修改文件的open、close操作;
  - 修改逻辑操作符;
  - 由设计变动引起的代码修改;
  - 修改对边界条件的测试。

- 数据副作用

  数据副作用指因修改软件的信息结构而带来的不良后果

  - 局部和全局常量的再定义;
  - 记录或文件格式的再定义;
  - 增减数据或其他复杂数据结构的体积;
  - 修改全局数据;
  - 重新初始化控制标志和指针;
  - 重新排列I/O表或子程序参数表。

- 文档副作用

  修改文档可能产生的副作用对非结构化维护不适应。
  对结构化维护要严防程序与文档的不匹配往往会出现这样一种现象。
  当发现错误后，程序员马上修改程序代码，但没有及时修改文档，这样，便产生程序代码与文档不一致，给以后的技术人员再阅读文档时带来更大的困难。

  维护应统一考虑整个软件配置，而不仅仅是源代码或者文档。
  否则,由于在设计文档和用户手册中未能准确反映修改情况而引起文档副作用。

  对软件的任何修改都应在相应的技术文档中反映出来,如果设计文档不能与软件当前的状况对应则比没有文档更糟。
  对用户来说,若使用说明中未能反映修改后的状况,那么用户在这些问题上必定出错。
  一次维护完成之后,再次交付软件之前应仔细复审整个配置,有效地减少文档副作用。

由于软件维护会产生副作用，所以，经过修改后的软件在提交给用户之前，应该进行确认和测试，以确保整个系统的正确性。

- 静态测试

  修改是否与规格说明有关；
  修改结果是否符合规格说明的要求；
  对规格说明是否有歪曲；
  程序的修改是否改正了软件中的问题；
  修改后的程序是否产生逻辑上的错误；
  修改部分是否因波及其他部分而产生副作用

- 计算机确认

  要确认测试的顺序，首先测试经过修改的部分，再测试没有修改的部分，然后，把它们集成起来测试；
  准备好标准的和有效的测试用例；
  充分利用软件工具帮助测试；
  在确认测试过程中，邀请用户参加。

- 文档验收

  所有的文档是否完备，是否更新，文档与程序是否一致；
  全部测试用例和测试结果是否都正确记载；
  软件配置是否都有了副本；
  维护的工序和责任是否已经确定。

##### 18.6 可维护性

软件可维护性是指纠正软件系统出现的错误和缺陷，以及为满足新的要求进行修改、扩充或压缩的容易程度。
可维护性、可使用性、可靠性是衡量软件质量的主要质量特性，也是用户十分关心的几个方面。
软件的可维护性是软件开发阶段各个时期的关键目标。

**用于衡量的七个特性：**

- 可理解性

  可理解性表明人们通过阅读源代码和相关文档，了解程序功能及其如何运行的容易程度。
  一个可理解的程序应具备以下一些特性：模块化，风格一致性，不使用令人捉摸不定或含糊不清的代码，使用有意义的数据名和过程名，结构化，完整性等。

- 可测试性

  可测试性表明论证程序正确性的容易程度。程序越简单，证明其正确性就越容易。而且设计合用的测试用例，取决于对程序的全面理解。
  一个可测试的程序应当是可理解的，可靠的，简单的。
  用于可测试性度量的检查项目如下：

  - 程序是否模块化? 结构是否良好?
  - 程序是否可理解? 程序是否可靠?

  - 程序是否能显示任意中间结果?

  - 程序是否能以清楚的方式描述它的输出?
  - 程序是否能及时地按照要求显示所有的输入?

  - 程序是否有跟踪及显示逻辑控制流程的能力?

  - 程序是否能从检查点再启动?

  - 程序是否能显示带说明的错误信息?

- 可修改性

  可修改性表明程序容易修改的程度。
  一个可修改的程序应当是可理解的、通用的、灵活的、简单的。
  通用性是指程序适用于各种功能变化而无需修改。
  灵活性是指能够容易地对程序进行修改

  > 设C是程序中各个模块的平均复杂性，n是必须修改的模块数，A 是要修改的模块的平均复杂性。 则修改的难度D由下式计算：                D = A / C

- 可靠性

  可靠性表明一个程序按照用户的要求和设计目标，在给定的一段时间内正确执行的概率。
  关于可靠性，度量的标准主要有：

  - 平均失效间隔时间MTTF

  - 平均修复时间MTTR

  - 有效性A = MTBD/(MTBD+MDT)

  方法：根据程序错误统计数字（计算MTTF等），进行可靠性预测。根据程序复杂性，预测软件可靠性。

- 可移植性

  可移植性表明程序转移到一个新的计算环境的可能性的大小。或者它表明程序可以容易地、有效地在各种各样的计算环境中运行的容易程度。
  一个可移植的程序应具有结构良好、灵活、不依赖于某一具体计算机或操作系统的性能

- 可使用性

  从用户观点出发，可使用性定义为程序方便、实用、及易于使用的程度。一个可使用的程序应是易于使用的、能允许用户出错和改变，并尽可能不使用户陷入混乱状态的程序。

- 效率

  效率表明一个程序能执行预定功能而又不浪费机器资源的程度。

  这些机器资源包括内存容量、外存容量、通道容量和执行时间。

对于不同类型的维护，这七个特性的侧重点也不一样。改正性维护：可理解性、可测试性、可修改性、可靠性；适应性维护：可修改性、可移植性、可使用性；完善性维护：可使用性、效率

**可维护性度量的方法：**

- 质量检查表（问题清单）
- 质量测试（用于定量分析和评价程序的质量）
- 质量标准（同上）

![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\MD0F1T$3SMP65E2428L`K9C.png)

这些数据反映了维护全过程中检错－纠错－验证的周期，即从检测出软件存在的问题开始至修正它们并经回归测试验证这段时间。可以粗略地认为，这个周期越短，维护越容易。

**提高可维护性**

- 建立明确的软件质量目标和优先级
- 使用提高软件质量的技术和工具
- 进行明确的质量保证审查
- 选择可维护的程序设计语言
- 改进程序的文档（系统开发日志、错误记载、系统维护日志）

##### 18.7 软件维护的管理

![img](file:///C:\Users\WindyZYY\AppData\Roaming\Tencent\Users\2461607010\QQ\WinTemp\RichOle\]QD4%B{XV2TCJ`55}1]VTES.png)

维护人员要和用户积极讨论

由谁来承担软件维护管理工作是维护管理的另一个重要问题。

